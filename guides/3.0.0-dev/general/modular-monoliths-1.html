<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a modular monolith with Spring Boot and Across - Across</title>
    <meta name="generator" content="Antora 2.0.0">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,800" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<meta name="og:title" content="Across Documentation"/>
<meta name="og:image" content="https://across.foreach.be/across/resources/static/acrossWebsite/img/og-image-across.jpg"/>
<link rel="icon" type="image/png" sizes="16x16" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/favicon-16x16.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="96x96" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/favicon-96x96.png"/>
<link rel="apple-touch-icon" type="image/png" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/apple-icon-120x120.png"/>
<link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/apple-icon-152x152.png"/>
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://across.foreach.be/across/resources/static/acrossWebsite/img/favicon/apple-icon-180x180.png"/>
  </head>
  <body class="article">
<header class="header" role="banner">
  <div class="m-mobile-menu__button js-overlay-menu-button" data-target="mobile-menu">
    <span class="m-mobile-menu__line"></span>
    <span class="m-mobile-menu__line"></span>
    <span class="m-mobile-menu__line"></span>
  </div>

  <div class="m-mobile-menu">
    <div class="m-mobile-menu__logo">
      <a class="m-nav__logo" href="https://across.foreach.be">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 82.9 95.7">
          <title>logo-across</title>
          <path fill="#3CA873" d="M0 23.9l15.9-9.2 41.5 23.9-16 9.2"></path>
          <path fill="#0093D8" d="M25.5 9.2L41.4 0l41.5 23.9-16 9.2"></path>
          <path fill="#53DD99" d="M41.4 95.7l16-9.3V38.6l-16 9.2"></path>
          <path fill="#22CEFA" d="M66.9 80.9l16-9.2V23.9l-16 9.2"></path>
          <path fill="#257A50" d="M12.5 64.5L28.9 55l-16.4-9.4"></path>
          <path fill="#4DBC86" d="M12.5 64.5L28.9 74V55"></path>
        </svg>
        <span>Across</span>
      </a>
    </div>
  </div>
  <div class="m-mobile-menu__container js-mobile-menu-overlay" id="mobile-menu">
    <nav class="m-mobile-menu__list">
      <a href="https://across.foreach.be/blog">Blog</a>
      <a href="https://across.foreach.be/documentation" class="is-active">Docs</a>
      <a href="https://across.foreach.be/modules">Modules</a>
      <a href="https://across.foreach.be/faq">FAQ</a>
      <a href="http://start-across.foreach.be">Get started</a>
    </nav>
  </div>
  <nav class="m-nav is-sticky">
    <a class="m-nav__logo" href="https://across.foreach.be">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 82.9 95.7">
        <title>logo-across</title>
        <path fill="#3CA873" d="M0 23.9l15.9-9.2 41.5 23.9-16 9.2"></path>
        <path fill="#0093D8" d="M25.5 9.2L41.4 0l41.5 23.9-16 9.2"></path>
        <path fill="#53DD99" d="M41.4 95.7l16-9.3V38.6l-16 9.2"></path>
        <path fill="#22CEFA" d="M66.9 80.9l16-9.2V23.9l-16 9.2"></path>
        <path fill="#257A50" d="M12.5 64.5L28.9 55l-16.4-9.4"></path>
        <path fill="#4DBC86" d="M12.5 64.5L28.9 74V55"></path>
      </svg>
      <span>Across</span>
    </a>

    <div class="m-nav__link-group">
      <a href="https://across.foreach.be/blog">Blog</a>
      <a href="https://across.foreach.be/documentation" class="is-active">Docs</a>
      <a href="https://across.foreach.be/modules">Modules</a>
      <a href="https://across.foreach.be/faq">FAQ</a>
      <a href="http://start-across.foreach.be">Get started</a>
    </div>
  </nav>
</header>
<div class="main-wrapper">
<div class="navigation-container" data-component="guides" data-version="3.0.0-dev">
  <aside class="navigation" role="navigation">
    <div class="panels">
      <div id="search-box" class="search-box is-active">
        <input id="search-input" type="text" placeholder="Search the documentation">
      </div>
      <div class="navigation-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Application Guides</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../modular-monoliths/index.html">Building a modular monolith</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../modular-monoliths/1-creating-a-module.html">Applications and modules</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../modular-monoliths/2-module-dependencies.html">Module dependencies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../modular-monoliths/3-using-module-components.html">Using module components</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../modular-monoliths/4-working-with-events.html">Working with events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../modular-monoliths/5-dynamic-application-module.html">Dynamic application module</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="../security/oauth2-sso.html">Adding security</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../security/oauth2-sso.html">OAuth2 with Single-Sign On</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
      <div class="navigation-explore" data-panel="explore">
  <div class="context">
    <span class="title">Application Guides</span>
    <span class="version">3.0.0-dev</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Across Platform</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../across/2.1.4-dev/index.html">2.1.4-dev</a>
        </li>
        <li class="version">
          <a href="../../../across/2.1.3/index.html">2.1.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">Application Guides</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">3.0.0-dev</a>
        </li>
        <li class="version">
          <a href="../../2.1.2/index.html">2.1.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Auto-configuration Support</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../across-autoconfigure/1.0.2/index.html">1.0.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Migration guides</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../migration/3.0.0-dev/index.html">3.0.0-dev</a>
        </li>
        <li class="version">
          <a href="../../../migration/2.1.2/index.html">2.1.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Admin Web</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../admin-web-module/3.1.0/index.html">3.1.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Application Info</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../application-info-module/1.0.1/index.html">1.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Batch Processing</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spring-batch-module/1.0.1/index.html">1.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Bootstrap UI</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../bootstrap-ui-module/2.2.0/index.html">2.2.0</a>
        </li>
        <li class="version">
          <a href="../../../bootstrap-ui-module/2.1.1/index.html">2.1.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Caching - Ehcache</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../ehcache-module/1.0.1/index.html">1.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Debug Web</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../debug-web-module/2.0.0/index.html">2.0.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Documents & Forms</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../dynamic-forms-module/0.0.3-dev/index.html">0.0.3-dev</a>
        </li>
        <li class="version">
          <a href="../../../dynamic-forms-module/0.0.2/index.html">0.0.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Entity Management</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../entity-module/4.0.0-dev/index.html">4.0.0-dev</a>
        </li>
        <li class="version">
          <a href="../../../entity-module/3.3.0-dev/index.html">3.3.0-dev</a>
        </li>
        <li class="version">
          <a href="../../../entity-module/3.2.0/index.html">3.2.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: File Management</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../file-manager-module/1.3.1-dev/index.html">1.3.1-dev</a>
        </li>
        <li class="version">
          <a href="../../../file-manager-module/1.3.0/index.html">1.3.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Hibernate JPA</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../hibernate-jpa-module/3.0.0/index.html">3.0.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: LDAP Support</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../ldap-module/2.0.0-dev/index.html">2.0.0-dev</a>
        </li>
        <li class="version">
          <a href="../../../ldap-module/1.0.1/index.html">1.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Logging</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../logging-module/2.0.0-dev/index.html">2.0.0-dev</a>
        </li>
        <li class="version">
          <a href="../../../logging-module/1.1.0/index.html">1.1.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Mobile Support</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spring-mobile-module/2.0.0/index.html">2.0.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Properties</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../properties-module/1.1.1/index.html">1.1.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Security</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spring-security-module/3.0.2/index.html">3.0.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Security - ACLs</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spring-security-acl-module/3.0.1/index.html">3.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Security - OAuth2</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../oauth2-module/2.1.0/index.html">2.1.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: User Management</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../user-module/3.1.0/index.html">3.1.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Web CMS</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../web-cms-module/0.0.7-dev/index.html">0.0.7-dev</a>
        </li>
        <li class="version">
          <a href="../../../web-cms-module/0.0.6/index.html">0.0.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
    <script>
      var indexName = window.location.href.indexOf('across-site/production/')>0 ? 'antora-across-site-production' : 'antora-across-site-preview';
      docsearch({
                  appId: 'YNK2RERBV5',
                  apiKey: '201d66bbf44a6c62002472e491d74568',
                  indexName: indexName,
                  inputSelector: '#search-input',
                  algoliaOptions: { hitsPerPage: 10 }
                })
    </script>
  </aside>
</div>
  <main class="main" role="main">
<div class="toolbar" role="navigation">
  <button class="navigation-toggle"></button>
  <a href="../../../across/2.1.3/index.html" class="home-link"></a>
<nav class="crumbs" role="navigation" aria-label="breadcrumbs">
  <ul>
    <li class="crumb"><a href="../index.html">Application Guides</a></li>
    <li class="crumb is-current"><a href="modular-monoliths-1.html">Building a modular monolith with Spring Boot and Across</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="versions-menu-toggle" title="Show other versions of page">3.0.0-dev</button>
  <div class="versions-menu">
    <a class="version is-current" href="modular-monoliths-1.html">3.0.0-dev</a>
    <a class="version" href="../../2.1.2/general/modular-monoliths-1.html">2.1.2</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/ForeachOS/ax-docs-platform/edit/develop-3.0.0/docs/guides/modules/ROOT/pages/general/modular-monoliths-1.adoc">Edit this Page</a></div>
</div>
<article class="doc"><a name="section-top"></a>
<h1>Building a modular monolith with Spring Boot and Across</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot is excellent for building Java applications, be it large monoliths or micro-services.
The challenge with monolithic applications is that the architecture often degrades over time, and some times they end up becoming a <em>big ball of mud</em>.</p>
</div>
<div class="paragraph">
<p>Developing your monoliths in a modular fashion can help you keep your architecture under control.
This is where Across framework comes into play, as it allows you to structure your Spring application with modules.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_about_this_post"><a class="anchor" href="#_about_this_post"></a>About this post</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this post we&#8217;ll be focusing on how you can define modules with Across, and how the modular approach is different from the regular Spring approach.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll explain:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>how to define an Across module and add it to your application</p>
</li>
<li>
<p>how to define dependencies between modules</p>
</li>
<li>
<p>how the bean creation differs from a regular Spring Boot application</p>
</li>
<li>
<p>how module dependencies impact the ordering of modules, beans and the handling of events</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to know some Spring Boot (or at least Spring framework), Java 8 and Maven to follow this tutorial.
We will also be using Lombok to generate some boilerplate code with annotations like <code>@Slf4j</code> and <code>@RequiredArgsConstructor</code>.</p>
</div>
<div class="paragraph">
<p>We take it very much step-by-step, explaining things on the way.
If you are more interested in the complete example, see the Github repository link at the end of this post.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s get started.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_our_application"><a class="anchor" href="#_creating_our_application"></a>Creating our application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start by creating our Spring Boot application.</p>
</div>
<div class="paragraph">
<p>Go to <a href="http://start-across.foreach.be" class="bare">http://start-across.foreach.be</a> and ensure that the option <code>Blank Across application without any modules</code> is selected.
Click on <code>Generate project</code>, download, unzip to a folder and import the project via the <code>pom.xml</code> in your favorite IDE.</p>
</div>
<div class="paragraph">
<p>When unzipped, you should see the following folder structure:</p>
</div>
<div class="listingblock">
<div class="title">Project structure</div>
<div class="content">
<pre class="highlightjs highlight"><code>src/
  main/
    java/
      com/example/demo/
        application/
        DemoApplication.java
    resources/
      application.yml
      application-dev.yml
      application-prod.yml
      build.properties
  test/
    java/
      com/example/demo/application/
      it/
        ITDemoApplication.java
.gitignore
README.md
lombok.config
pom.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s only 2 java classes added:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DemoApplication</code> which represents the Spring Boot application</p>
</li>
<li>
<p><code>ITDemoApplication</code> which is an integration test for bootstrapping the application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s a have quick look at the source code of <code>DemoApplication</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/DemoApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AcrossApplication(
		modules = {

		}
)
public class DemoApplication
{
	public static void main( String[] args ) {
		SpringApplication springApplication = new SpringApplication( DemoApplication.class );
		springApplication.setDefaultProperties( Collections.singletonMap( "spring.config.location", "${user.home}/dev-configs/demo-application.yml" ) );
		springApplication.run( args );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is run as a <code>SpringApplication</code> but instead of <code>@SpringBootApplication</code> the class is annotated with <code>@AcrossApplication</code> signaling we want to bootstrap as a modular application based on Across.</p>
</div>
<div class="paragraph">
<p>In an Across application we also call this file the <strong>application descriptor</strong>.</p>
</div>
<div class="paragraph">
<p>Currently our application descriptor is empty, there are no modules added to it.
Let&#8217;s boot up our newly created application.</p>
</div>
<div class="sect2">
<h3 id="_run_the_application"><a class="anchor" href="#_run_the_application"></a>Run the application</h3>
<div class="paragraph">
<p>You can simply execute the <code>DemoApplication</code> <code>main</code> method to run the application.
From a terminal you can also use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ mvn spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>When starting up the application, you should find the following in the console output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>: ---
: AcrossContext: DemoApplication (AcrossContext-1)
: Bootstrapping 2 modules in the following order:
: 1 - DemoApplicationModule [resources: demo]: class com.foreach.across.core.DynamicAcrossModule$DynamicApplicationModule
: 2 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
: ---</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a very important piece of information for our application: it tells us which modules are being started and in which order.
We will come back to this later on, but you should make sure you can always easily retrieve this from the logs.</p>
</div>
<div class="paragraph">
<p>Even though we don&#8217;t specify any modules ourselves, we can see that the application bootstraps 2 modules that are added by default.
You can ignore these for now, we&#8217;ll explain them towards the end of this post.</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_the_application"><a class="anchor" href="#_testing_the_application"></a>Testing the application</h3>
<div class="paragraph">
<p>Apart from running the main class, you should also be able to run the integration test: <code>ITDemoApplication</code>.</p>
</div>
<div class="paragraph">
<p>If you want to run all integration tests from the terminal, you can do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ mvn integration-test</pre>
</div>
</div>
<div class="paragraph">
<p>But usually I just execute the test class or test method directly from the IDE.</p>
</div>
<div class="paragraph">
<p>The integration tests bootstraps the entire <code>DemoApplication</code> as well, and is pre-configured for a Spring MVC testing scenario (using <code>MockMvc</code>).
We won&#8217;t be using that in the rest of this tutorial however.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_a_component"><a class="anchor" href="#_adding_a_component"></a>Adding a component</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we can boot up our application, let&#8217;s add some code to it.
Let&#8217;s start by adding a component in the same package as the <code>DemoApplication</code> class.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/ComponentOne.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo;

@Component
@Slf4j
public class ComponentOne
{
	public ComponentOne() {
		LOG.info( "Component created: {}", getClass() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This class declares a simple bean component that should get instantiated when Spring scans the package for all classes annotated with <code>@Component</code>.
However, when you re-run the application integration test, you <strong>should not find</strong> the test <em>Component created</em> anywhere, meaning our component actually did not get created.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you do find the output, you probably added the component to the <code>application</code> child package.
Move it next to the <code>DemoApplication</code> instead, we will explain the purpose of the <code>application</code> package at the end of this post.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a regular <code>@SpringBootApplication</code> we would expect Spring Boot to scan the root package and all child packages below for components.
An <code>@AcrossApplication</code> however encourages you to bundle your components in separate modules, and to only treat the application class as a descriptor for which modules should be added.</p>
</div>
<div class="paragraph">
<p>In fact, if you were to manually add a <code>@ComponentScan</code> directly on the <code>DemoApplication</code> class, starting the application would fail altogether (with a specific error message).</p>
</div>
<div class="paragraph">
<p>In order to continue, we must put our component in an Across module.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_an_across_module"><a class="anchor" href="#_creating_an_across_module"></a>Creating an Across module</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every module is identified by a unique name and a <em>module descriptor</em>, a class extending <code>AcrossModule</code>.
As a convention and to help you separate your code, each module usually resides in its own base package.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a package <code>com.example.demo.modules.one</code> and add a module descriptor to it:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/one/ModuleOne.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.one;

public class ModuleOne extends AcrossModule
{
	@Override
	public String getName() {
		return "ModuleOne";
	}

	@Override
	protected void registerDefaultApplicationContextConfigurers( Set&lt;ApplicationContextConfigurer&gt; contextConfigurers ) {
		contextConfigurers.add( ComponentScanConfigurer.forAcrossModule( ModuleOne.class ) );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This class is a module descriptor that defines a module named <code>ModuleOne</code>, and configures it so it scans its package for components when starting up.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s move the previously created <code>ComponentOne</code> to the same package and rename it to <code>InternalComponentOne</code>.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/one/InternalComponentOne.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.one;

@Component
@Slf4j
public class InternalComponentOne
{
	public InternalComponentOne() {
		LOG.info( "Component created: {}", getClass() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should end up with the following project structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.example.demo/
  modules/
    one/
      ModuleOne
      InternalComponentOne
  DemoApplication</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have defined a new module (<code>ModuleOne</code>) which will contain a single component (<code>InternalComponentOne</code>) when it is started.
All that&#8217;s left to do is to add our newly defined module to our application.
We can do that by adding the module descriptor as a bean in the <code>DemoApplication</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/DemoApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AcrossApplication(
		modules = {

		}
)
public class DemoApplication {
    @Bean
    public ModuleOne moduleOne() {
        return new ModuleOne();
    }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you now run the integration test or re-start the application, you should see that <code>ModuleOne</code> was added and that <code>InternalComponentOne</code> got created.</p>
</div>
<div class="listingblock">
<div class="title">Console output excerpt</div>
<div class="content">
<pre class="highlightjs highlight"><code>: ---:
: AcrossContext: DemoApplication (AcrossContext-1)
: Bootstrapping 3 modules in the following order:
: 1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
: 2 - DemoApplicationModule [resources: demo]: class com.foreach.across.core.DynamicAcrossModule$DynamicApplicationModule
: 3 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
: ---
: ...
: --- Starting module bootstrap
:
: 1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
: Refreshing ModuleOne: startup date [Wed Sep 26 08:57:46 CEST 2018]; parent: AcrossContext-1
: ...
: Component created: class com.example.demo.modules.one.InternalComponentOne
:
: 2 - DemoApplicationModule [resources: demo]: class com.foreach.across.core.DynamicAcrossModule$DynamicApplicationModule</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_an_across_module_in_isolation"><a class="anchor" href="#_testing_an_across_module_in_isolation"></a>Testing an Across module in isolation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Part of the modularization aspect is that it should help you define and manage your dependencies.
As such it is also important that you can test your modules in isolation: with the minimum set of required dependencies.</p>
</div>
<div class="paragraph">
<p>Our newly created <code>ModuleOne</code> does not declare any explicit dependencies on other modules.
So let&#8217;s create a separate integration test that bootstraps our module all by itself.</p>
</div>
<div class="paragraph">
<p>We can do so by using the <code>across-test</code> features that have automatically been added to the project.</p>
</div>
<div class="paragraph">
<p>Create a new test class which we will use for separate module integration testing:</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Slf4j
public class TestModuleBootstrapScenarios
{
	@Test
	public void moduleOneShouldBootstrapInIsolation() {
		try (AcrossTestContext ignore = AcrossTestBuilders.standard( false )
		                                                  .modules( new ModuleOne() )
		                                                  .build()) {
			LOG.trace( "Bootstrap successful." );
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test creates an Across context configuration that only starts <code>ModuleOne</code>.
Since we do not need any web features, we create a <code>standard</code> configuration.
And since we do not require a database, we disable the default test datasource (the <code>false</code> argument).
The latter simply ensures that our test executes a bit faster.</p>
</div>
<div class="paragraph">
<p>We&#8217;re using a try-with-resources approach to ensure that everything gets cleaned up nicely afterwards.
Our test simply checks that starting up works and writes a log message, we don&#8217;t validate anything else.</p>
</div>
<div class="paragraph">
<p>You should now have the following structure for your test code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
  test/
    java
      com.example.demo/
      it/
        ITDemoApplication.java
      test/
        TestModuleBootstrapScenarios.java</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note about the tests package structure</div>
<div class="paragraph">
<p>We have created no less than 3 package structures for our tests.
This is not any form of requirement but simply a conventional approach we prefer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.example.demo</code> contains the actual unit tests, often tests that reside in the same package as the units of code they are testing</p>
</li>
<li>
<p><code>test</code> contains partial integration tests, integration tests for "parts of the application"</p>
</li>
<li>
<p><code>it</code> contains the full-stack integration tests, in this case tests that bootstrap the entire application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the Maven configuration provided by the initializr, the <code>it</code> integration tests are only run with the <code>integration-test</code> goal, whereas all others are executed when using <code>mvn test</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You should be able to execute test <code>moduleOneShouldBootstrapInIsolation()</code> successfully and find the following in the console output:</p>
</div>
<div class="listingblock">
<div class="title">Test console output excerpt</div>
<div class="content">
<pre class="highlightjs highlight"><code>---
AcrossContext: AcrossContext-1 (AcrossContext-1)
Bootstrapping 2 modules in the following order:
1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
2 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DemoApplicationModule</code> - a feature of using the <code>@AcrossApplication</code> annotation - is now no longer available.
The <code>AcrossContextPostProcessorModule</code> is automatically added by the Across framework and cannot be removed, it always exists.</p>
</div>
<div class="sect2">
<h3 id="_cleaning_up_the_test_logging_output"><a class="anchor" href="#_cleaning_up_the_test_logging_output"></a>Cleaning up the test logging output</h3>
<div class="paragraph">
<p>You might notice that you get a lot more logging output when running this unit test.
This is because when using <code>@AcrossApplication</code> a default logging configuration gets initialized, but that is not the case when using the <code>AcrossTestBuilders</code>.</p>
</div>
<div class="paragraph">
<p>The easiest way to fix this is to provide a <code>logback-test.xml</code> in your test resources, and to import a pre-configured sample configuration which comes with the <code>across-test</code> dependency.</p>
</div>
<div class="listingblock">
<div class="title">src/test/resources/logback-test.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
	&lt;include resource="logback-across-test.xml"/&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When added correctly, this should be the full console output of running <code>moduleOneShouldBootstrapInIsolation()</code>:</p>
</div>
<div class="listingblock">
<div class="title">Console output with logback-test.xml in place</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">AcrossBootstrapper: ---
AcrossBootstrapper: AcrossContext: AcrossContext-1 (AcrossContext-1)
AcrossBootstrapper: Bootstrapping 2 modules in the following order:
AcrossBootstrapper: 1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
AcrossBootstrapper: 2 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
AcrossBootstrapper: ---
AcrossConfig: Creating a default ConversionService as no valid bean 'conversionService' is present
AcrossBootstrapper:
AcrossBootstrapper: --- Starting module bootstrap
AcrossBootstrapper:
AcrossBootstrapper: 1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
AcrossDevelopmentMode: Across development mode active: false
InternalComponentOne: Component created: class com.example.demo.modules.one.InternalComponentOne
AcrossBootstrapper:
AcrossBootstrapper: 2 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
AcrossBootstrapper: Nothing to be done - disabling module
AcrossBootstrapper: --- Module bootstrap finished: 1 modules started
AcrossBootstrapper:
AcrossContext: Shutdown signal received - destroying ApplicationContext instances</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far we have added a single module to our application, and tested it in isolation.
Let&#8217;s make things a bit more interesting and create a second module.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_a_second_module"><a class="anchor" href="#_adding_a_second_module"></a>Adding a second module</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a second package <code>modules.two</code> and more or less copy the configuration of <code>ModuleOne</code>: create an equivalent module descriptor and internal component.</p>
</div>
<div class="listingblock">
<div class="title">/src/main/java/com/example/demo/modules/two/ModuleTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.two;

public class ModuleTwo extends AcrossModule
{
	@Override
	public String getName() {
		return "ModuleTwo";
	}

	@Override
	protected void registerDefaultApplicationContextConfigurers( Set&lt;ApplicationContextConfigurer&gt; contextConfigurers ) {
		contextConfigurers.add( ComponentScanConfigurer.forAcrossModule( ModuleTwo.class ) );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">/src/main/java/com/example/demo/modules/two/InternalComponentTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.two;

@Component
@Slf4j
public class InternalComponentTwo
{
	public InternalComponentTwo() {
		LOG.info( "Component created: {}", getClass() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your project structure now looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.example.demo/
  modules/
    one/
      ModuleOne
      InternalComponentOne
    two/
      ModuleTwo
      InternalComponentTwo
  DemoApplication</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add an integration test for the second module.</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void moduleTwoShouldBootstrap() {
    try (AcrossTestContext ignore = AcrossTestBuilders.standard( false ).modules( new ModuleTwo() ).build()) {
        LOG.trace( "Bootstrap successful." );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to run this test successfully.</p>
</div>
<div class="sect2">
<h3 id="_adding_a_component_dependency"><a class="anchor" href="#_adding_a_component_dependency"></a>Adding a component dependency</h3>
<div class="paragraph">
<p>Let&#8217;s add a component dependency on <code>InternalComponentTwo</code>.
Add a constructor injection dependency to component <code>InternalComponentOne</code>.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/two/InternalComponentTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Slf4j
public class InternalComponentTwo
{
    private final InternalComponentOne internalComponentOne;

    public InternalComponentTwo(InternalComponentOne internalComponentOne) {
        LOG.info("Component created: {} (using {})", getClass(), internalComponentOne);

        this.internalComponentOne = internalComponentOne;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a regular Spring bean dependency.
This code compiles as <code>InternalComponentOne</code> is a public class, but if you run the test, it fails with exception:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>No qualifying bean of type 'com.example.demo.modules.one.InternalComponentOne' available</pre>
</div>
</div>
<div class="paragraph">
<p>Which makes sense, as <code>InternalComponentOne</code> is a bean created in <code>ModuleOne</code> but our <code>ModuleTwo</code> does not have a dependency on <code>ModuleOne</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_module_dependency"><a class="anchor" href="#_adding_a_module_dependency"></a>Adding a module dependency</h3>
<div class="paragraph">
<p>In a module approach, a module can explicitly define a dependency on another module.
You can do so using <code>@AcrossDepends</code> on the module descriptor.</p>
</div>
<div class="paragraph">
<p>Change the <code>ModuleTwo</code> descriptor to add an explicit dependency on <code>ModuleOne</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.two;

@AcrossDepends(required = "ModuleOne")
public class ModuleTwo extends AcrossModule
{
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This dependency is <code>required</code>, meaning that the application must not start if the dependency is not met.
We refer to the module we depend on by name, as a module name is expected to be unique.</p>
</div>
<div class="paragraph">
<p>If you re-run the <code>moduleTwoShouldBootstrap()</code> test, it now fails with another, clear exception:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com.foreach.across.core.context.bootstrap.ModuleDependencyMissingException: Unable to bootstrap AcrossContext as module ModuleTwo requires module ModuleOne. Module ModuleOne is not present in the context.</pre>
</div>
</div>
<div class="paragraph">
<p>This is expected behaviour.
We have stipulated a dependency on <code>ModuleOne</code>, but have not added <code>ModuleOne</code> to our test configuration yet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cleaning_up_the_tests"><a class="anchor" href="#_cleaning_up_the_tests"></a>Cleaning up the tests</h3>
<div class="paragraph">
<p>Let&#8217;s split up our single test case into two separate tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>one that verifies bootstrapping fails if <code>ModuleOne</code> is not present</p>
</li>
<li>
<p>one that verifies bootstrapping works if <code>ModuleOne</code> is present</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test(expected = ModuleDependencyMissingException.class)
public void moduleTwoRequiresModuleOne() {
    try (AcrossTestContext ignore = AcrossTestBuilders.standard( false )
                                                      .modules( new ModuleTwo() )
                                                      .build()) {
        fail( "Should not have bootstrapped." );
    }
}

@Test
public void moduleTwoBootstrapsIfOneIsPresent() {
    try (AcrossTestContext ignore = AcrossTestBuilders.standard( false )
                                                      .modules( new ModuleTwo(), new ModuleOne() )
                                                      .build()) {
        LOG.trace( "Bootstrap successful." );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run the tests, <code>moduleTwoRequiresModuleOne()</code> succeeds, but <code>moduleTwoBootstrapsIfOneIsPresent()</code> fails again with the original exception:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>No qualifying bean of type 'com.example.demo.modules.one.InternalComponentOne' available</pre>
</div>
</div>
<div class="paragraph">
<p>Even though in the console log we can see that <code>InternalComponentOne</code> gets created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>: --- Starting module bootstrap
:
: 1 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
: Across development mode active: false
: Component created: class com.example.demo.modules.one.InternalComponentOne
:
: 2 - ModuleTwo [resources: ModuleTwo]: class com.example.demo.modules.two.ModuleTwo
: Exception encountered during context initialization</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ModuleOne</code> starts up fine and creates <code>InternalComponentOne</code>, but bootstrapping <code>ModuleTwo</code> fails when it tries to resolve the <code>InternalComponentOne</code> dependency.</p>
</div>
<div class="paragraph">
<p>So what is going on here?</p>
</div>
</div>
<div class="sect2">
<h3 id="_exposing_beans"><a class="anchor" href="#_exposing_beans"></a>Exposing beans</h3>
<div class="paragraph">
<p>In a modular approach with Across, all beans are contained within their module unless otherwise <em>exposed</em>.
This means that even though <code>InternalComponentOne</code> is a publicly accessible class, and there is a singleton bean created for it, that bean can only be accessed from within <code>ModuleOne</code>.
For <code>ModuleTwo</code> there is no component <code>InternalComponentOne</code> available.</p>
</div>
<div class="paragraph">
<p>To fix this, we can <em>expose</em> <code>InternalComponentOne</code> by annotating it with <code>@Exposed</code>.
Instead of exposing the internal component however, let&#8217;s create a separate exposed component and use that one as a dependency in <code>InternalComponentTwo</code>.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/one/ExposedComponentOne.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.one;

@Component
@Exposed
public class ExposedComponentOne implements Supplier&lt;String&gt;
{
	@Override
	public String get() {
		return "hello from module one";
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/two/InternalComponentTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Slf4j
public class InternalComponentTwo
{
	private final ExposedComponentOne exposedComponentOne;

	public InternalComponentTwo( ExposedComponentOne exposedComponentOne ) {
		LOG.info( "Component created: {} (using {})", getClass(), exposedComponentOne );

		this.exposedComponentOne = exposedComponentOne;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your project structure should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.example.demo/
  modules/
    one/
      ModuleOne
      InternalComponentOne
      ExposedComponentOne
    two/
      ModuleTwo
      InternalComponentTwo
  DemoApplication</code></pre>
</div>
</div>
<div class="paragraph">
<p>All tests should be green.</p>
</div>
</div>
<div class="sect2">
<h3 id="_verifying_exposed_beans"><a class="anchor" href="#_verifying_exposed_beans"></a>Verifying exposed beans</h3>
<div class="paragraph">
<p>Our integration test for <code>ModuleTwo</code> indirectly tests that <code>ModuleOne</code> exposes the correct component.
Often you also want to test in the scope of your module which beans it exposed.
Let&#8217;s update the module one test accordingly:</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void moduleOneShouldBootstrapInIsolation() {
    try (AcrossTestContext context = AcrossTestBuilders.standard(false)
            .modules(new ModuleOne())
            .build()) {
        assertNotNull(context.getBeanOfType(ExposedComponentOne.class));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <code>AcrossTestContext</code> to retrieve the exposed bean.
If you comment or remove <code>@Exposed</code> on <code>ExposedComponentOne</code>, this test will fail.</p>
</div>
<div class="paragraph">
<p>As we&#8217;ll see in another example below, there are other ways to expose beans.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_module_ordering"><a class="anchor" href="#_module_ordering"></a>Module ordering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a regular Spring application, beans often know which other beans exist even before those other beans have been created.
In an Across application this works differently: a bean can only know which beans another module provides once that other module has started.
This means that even though <code>ExposedComponentOne</code> is exposed, it is required that <code>ModuleOne</code> is fully bootstrapped before <code>ModuleTwo</code> attempts to retrieve the exposed bean.</p>
</div>
<div class="paragraph">
<p>It is the correct use of <code>@AcrossDepends</code> that ensures this: <code>ModuleTwo</code> explicitly depends on <code>ModuleOne</code>, which means <code>ModuleOne</code> will be guaranteed to have been started before <code>ModuleTwo</code>.
This also means that all components that make up <code>ModuleOne</code> will have been created.
This type of ordering is fundamentally different from regular Spring applications, in which it is quite difficult to ensure the creation order of an entire group of beans, without depending on each one of them separately.</p>
</div>
<div class="paragraph">
<p>This type of reliable bootstrap ordering also means that cyclic dependencies are not possible: having a cyclic dependency between 2 modules (direct or indirect) will not allow your application to start.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s put it to the test.</p>
</div>
<div class="sect2">
<h3 id="_non_deterministic_bootstrap_order"><a class="anchor" href="#_non_deterministic_bootstrap_order"></a>Non-deterministic bootstrap order</h3>
<div class="paragraph">
<p>Put the <code>@AcrossDepends(required = "ModuleOne")</code> annotation on <code>ModuleTwo</code> in comments.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at our test method:</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void moduleTwoBootstrapsIfOneIsPresent() {
    try (AcrossTestContext ignore = AcrossTestBuilders.standard(false)
            .modules(new ModuleTwo(), new ModuleOne())
            .build()) {
        LOG.trace("Bootstrap successful.");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We no longer have defined a dependency between <code>ModuleOne</code> and <code>ModuleTwo</code>, this means <em>they don&#8217;t care about each other</em>.
In our test configuration example, we register them with <code>.modules(new ModuleTwo(), new ModuleOne())</code>: <code>ModuleTwo</code> is registered before <code>ModuleOne</code>.
Since there is no dependency based ordering, the registration order will be kept, causing the test to fail.</p>
</div>
<div class="paragraph">
<p>Play around with reversing the registration order, in the console output you can clearly see its impact on the bootstrap order:</p>
</div>
<div class="listingblock">
<div class="title">Test console output excerpt</div>
<div class="content">
<pre class="highlightjs highlight"><code>: AcrossContext: AcrossContext-1 (AcrossContext-1)
: Bootstrapping 3 modules in the following order:
: 1 - ModuleTwo [resources: ModuleTwo]: class com.example.demo.modules.two.ModuleTwo
: 2 - ModuleOne [resources: ModuleOne]: class com.example.demo.modules.one.ModuleOne
: 3 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
: ---</code></pre>
</div>
</div>
<div class="paragraph">
<p>This illustrates the importance of clearly defining your module dependencies.
The reliable implicit ordering resulting from it is one of the foremost features for building modular applications.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how that ordering propagates throughout the application.
Make sure you have uncommented the <code>@AcrossDepends</code> on <code>ModuleTwo</code> again before continuing.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_component_ordering"><a class="anchor" href="#_component_ordering"></a>Component ordering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We created <code>ExposedComponentOne</code> as an implementation of <code>Supplier&lt;String&gt;</code>.
Let&#8217;s create another new module which has a component that retrieves all <code>Supplier&lt;String&gt;</code> implementations and returns their class names.</p>
</div>
<div class="paragraph">
<p>Start by adding the module descriptor for <code>ModuleThree</code> which declares a dependency on <code>ModuleOne</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/ModuleThree.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.three;

@AcrossDepends(required="ModuleOne")
public class ModuleThree extends AcrossModule
{
	@Override
	public String getName() {
		return "ModuleThree";
	}

	@Override
	protected void registerDefaultApplicationContextConfigurers( Set&lt;ApplicationContextConfigurer&gt; contextConfigurers ) {
		contextConfigurers.add( ComponentScanConfigurer.forAcrossModule( ModuleThree.class ) );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a <code>SupplierService</code> component which wires all <code>Supplier&lt;String&gt;</code> beans.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/SupplierService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.three;

@Service
@RequiredArgsConstructor
public class SupplierService
{
	private Collection&lt;Supplier&lt;String&gt;&gt; suppliers = Collections.emptyList();

	@Autowired
	public void setSuppliers( Collection&lt;Supplier&lt;String&gt;&gt; suppliers ) {
		this.suppliers = suppliers;
	}

	public Collection&lt;String&gt; getSupplierNames() {
		return suppliers.stream()
		                .map( Object::getClass )
		                .map( Class::getSimpleName )
		                .collect( Collectors.toList() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because we will change it later on, we deliberately use setter injection with <code>@Autowired</code> in this class.</p>
</div>
<div class="paragraph">
<p>We want to have the <code>SupplierService</code> exposed for other modules, but instead of a regular <code>@Component @Exposed</code> we use the <code>@Service</code> annotation.
Beans annotated with <code>@Service</code> are exposed by default.</p>
</div>
<div class="paragraph">
<p>Your project structure should now look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.example.demo/
  modules/
    one/
      ModuleOne
      InternalComponentOne
      ExposedComponentOne
    two/
      ModuleTwo
      InternalComponentTwo
    three/
      ModuleThree.java
      SupplierService.java
  DemoApplication</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add an integration test to check that our <code>SupplierService</code> finds the <code>ExposedComponentOne</code> implementation.</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void supplierServiceFromModuleThreeListsDetectedSuppliers() {
    try (AcrossTestContext ctx = AcrossTestBuilders.standard(false)
            .modules(new ModuleThree(), new ModuleOne())
            .build()) {
        SupplierService supplierService = ctx.getBeanOfType(SupplierService.class);
        assertEquals(Collections.singletonList("ExposedComponentOne"), supplierService.getSupplierNames());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test should succeed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>because of the module dependencies, <code>ModuleThree</code> starts after <code>ModuleOne</code> and can access the exposed <code>ExposedComponentOne</code></p>
</li>
<li>
<p><code>SupplierService</code> is created with the list of <code>Supplier&lt;String&gt;</code> beans it can find, which currently is only <code>ExposedComponentOne</code></p>
</li>
<li>
<p><code>SupplierService</code> is itself is exposed and can be accessed from the unit test</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_adding_an_exposed_component"><a class="anchor" href="#_adding_an_exposed_component"></a>Adding an exposed component</h3>
<div class="paragraph">
<p>Let&#8217;s also add an exposed component implementing <code>Supplier&lt;String&gt;</code> to <code>ModuleTwo</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/two/ExposedComponentTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules.two;

@Component
@Exposed
public class ExposedComponentTwo implements Supplier&lt;String&gt;
{
	@Override
	public String get() {
		return "hello from module two";
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to ensure that our <code>SupplierService</code> can also detect this component, we now also need to make sure that <code>ModuleThree</code> starts after <code>ModuleTwo</code>.
We could add another required dependency, but that would mean that <code>ModuleThree</code> will only start if both <code>ModuleOne</code> and <code>ModuleTwo</code> are present.</p>
</div>
<div class="paragraph">
<p>But what if we simply want <code>ModuleThree</code> to list the available suppliers, without enforcing any other modules to be present?</p>
</div>
</div>
<div class="sect2">
<h3 id="_optional_module_dependencies"><a class="anchor" href="#_optional_module_dependencies"></a>Optional module dependencies</h3>
<div class="paragraph">
<p>Suppose we change our integration test for the the <code>SupplierService</code> to the following:</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void supplierServiceFromModuleThreeListsDetectedSuppliersInOrder() {
    expectSuppliers( Collections.emptyList() );
    expectSuppliers( Collections.singletonList( "ExposedComponentOne" ), new ModuleOne() );
    expectSuppliers( Arrays.asList( "ExposedComponentOne", "ExposedComponentTwo" ), new ModuleOne(), new ModuleTwo() );
}

private void expectSuppliers( Collection&lt;String&gt; names, AcrossModule... additionalModules ) {
    try (AcrossTestContext ctx = AcrossTestBuilders.standard( false )
                                                   .modules( new ModuleThree() )
                                                   .modules( additionalModules )
                                                   .build()) {
        SupplierService supplierService = ctx.getBeanOfType( SupplierService.class );
        assertEquals( names, supplierService.getSupplierNames() );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test bootstraps different module combinations, and tests that the <code>SupplierService</code> always detects the correct set of suppliers.</p>
</div>
<div class="paragraph">
<p>One way we can make this test succeed is to put optional dependencies on <code>ModuleThree</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/ModuleThree.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AcrossDepends(optional={"ModuleOne", "ModuleTwo"})
public class ModuleThree extends AcrossModule
{
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And to make the <code>Collection&lt;Supplier&lt;String&gt;&gt;</code> dependency optional as well:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/SupplierService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SupplierService
{
    ...
    @Autowired(required=false)
    public void setSuppliers(Collection&lt;Supplier&lt;String&gt;&gt; suppliers) {
        this.suppliers = suppliers;
    }
    ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference between a required and an optional module dependency is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a required dependency is missing, the bootstrap will fail. If an optional dependency is missing, bootstrap will continue as normal.</p>
</li>
<li>
<p>Cyclic required dependencies are not allowed, and a required dependency is guaranteed to have started before the module depending on it.
Cyclic optional dependencies are not advised but possible: a best-effort attempt will be made to start an optional dependency before the module depending on it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even though the test is now successful, this is not an optimal approach: whenever we add another module we would have to update the <code>ModuleThree</code> dependencies to ensure it can detect the <code>Supplier</code>.
A different way to tackle this type of problem is to use a refreshable collection.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_refreshable_collection"><a class="anchor" href="#_using_a_refreshable_collection"></a>Using a refreshable collection</h3>
<div class="paragraph">
<p>A refreshable collection is a collection type dependency that will update itself once all modules in an application have been started.</p>
</div>
<div class="paragraph">
<p>Remove <code>@AcrossDepends</code> from the <code>ModuleThree</code> class, and replace the <code>@Autowired(required=false)</code> from the <code>SupplierService</code> by <code>@RefreshableCollection</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/SupplierService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SupplierService
{
    ...
    @RefreshableCollection
    public void setSuppliers(Collection&lt;Supplier&lt;String&gt;&gt; suppliers) {
        this.suppliers = suppliers;
    }
    ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run the tests you will see they all succeed.
Even though <code>ModuleThree</code> no longer has any module dependencies and might even bootstrap before <code>ModuleOne</code> and <code>ModuleTwo</code>, the collection of suppliers is always up-to-date once the entire application has started.</p>
</div>
<div class="paragraph">
<p>Another very important fact is that result of <code>SupplierService.getSupplierNames()</code> is deterministic.
No matter how many times you re-run the test, it will always succeed, meaning that the beans are always returned in exactly the same order.</p>
</div>
<div class="paragraph">
<p>When you get a collection of beans from different modules, they will be implicitly ordered in the bootstrap order of the modules that defined them.</p>
</div>
<div class="paragraph">
<p>We find the same reliable ordering principle in event handling as well, let&#8217;s look at an example with events.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_events"><a class="anchor" href="#_working_with_events"></a>Working with events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like with distributed systems, using events for inter-module communication can be a very effective way to reduce coupling in your application.
Working with events in an Across application is done with the exact same features as in a regular Spring application, but module ordering influences how events are handled.
Let&#8217;s have a look.</p>
</div>
<div class="paragraph">
<p>Create a sample <code>SomeEvent</code> class which we will publish.
In this case, put it in the <code>com.example.demo.modules</code> package to illustrate it is part of the code shared between all modules.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/SomeEvent.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo.modules;

import java.util.ArrayList;

public class SomeEvent extends ArrayList&lt;String&gt;
{
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our event is nothing more than an <code>ArrayList</code> implementation to which every listener will add its own name.</p>
</div>
<div class="paragraph">
<p>Update the <code>SupplierService</code> with a new method which publishes the event and returns the names of all listeners that handled it.
At the same time, add an <code>@EventListener</code> method in the <code>SupplierService</code> which listens for the same event.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/SupplierService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
@RequiredArgsConstructor
public class SupplierService
{
	private final ApplicationEventPublisher eventPublisher;

	...

	public Collection&lt;String&gt; getEventListeners() {
		SomeEvent event = new SomeEvent();
		eventPublisher.publishEvent( event );
		return event;
	}

	@EventListener
	public void receive( SomeEvent event ) {
		event.add( getClass().getSimpleName() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also add some event listeners to the internal components of both <code>ModuleOne</code> and <code>ModuleTwo</code></p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/moduls/one/InternalComponentOne.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Slf4j
public class InternalComponentOne
{
	...

	@EventListener
	public void receive( SomeEvent event ) {
		event.add( getClass().getSimpleName() );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/moduls/two/InternalComponentTwo.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Slf4j
public class InternalComponentTwo
{
	...

	@EventListener
	public void receive( SomeEvent event ) {
		event.add( getClass().getSimpleName() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally write an integration test that bootstraps our modules and verifies the list of event listeners.</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/test/TestModuleBootstrapScenarios.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void eventIsHandledInModuleOrder() {
    try (AcrossTestContext ctx = AcrossTestBuilders.standard( false )
                                                   .modules( new ModuleThree(), new ModuleOne(), new ModuleTwo() )
                                                   .build()) {
        SupplierService supplierService = ctx.getBeanOfType( SupplierService.class );
        assertEquals( Arrays.asList( "SupplierService", "InternalComponentOne", "InternalComponentTwo" ), supplierService.getEventListeners() );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No matter how often you run it, this test should always succeed.
Without explicit ordering on the <code>@EventListener</code> methods, the bootstrap order ensures that events are always handled in the same order.</p>
</div>
<div class="paragraph">
<p>Here is a run-down of what happens exactly:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the modules are bootstrapped in the order <code>ModuleThree</code>, <code>ModuleOne</code>, <code>ModuleTwo</code></p>
</li>
<li>
<p><code>SomeEvent</code> is published by the <code>SupplierService</code> inside <code>ModuleThree</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>SupplierService.receive()</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>InternalComponentOne.receive()</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>InternalComponentTwo.receive()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Even though <code>SupplierService</code> publishes the event, it will always be handled in module order.
This is might seem obvious with the above example, but let&#8217;s shift the order around in our test:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.modules( new ModuleTwo(), new ModuleThree(), new ModuleOne() )</pre>
</div>
</div>
<div class="paragraph">
<p>If we simply re-run the test it now fails, as the order of handlers has changed.
Let&#8217;s go over it step-by-step:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the modules are now bootstrapped in the order <code>ModuleOne</code>, <code>ModuleTwo</code>, <code>ModuleThree</code></p>
</li>
<li>
<p><code>SomeEvent</code> is published by the <code>SupplierService</code> inside <code>ModuleThree</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>InternalComponentOne.receive()</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>InternalComponentTwo.receive()</code></p>
</li>
<li>
<p><code>SomeEvent</code> is handled by <code>SupplierService.receive()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Because <code>ModuleTwo</code> has a dependency on <code>ModuleOne</code>, the relative ordering of those two modules will always be the same.
<code>ModuleThree</code> has no dependencies, and because the registration order of our configuration has changed, it is now bootstrapped as the last module.
Even though the event is published by that module, it is last when it comes to handling that same event!</p>
</div>
<div class="paragraph">
<p>Properly using events is a great way for building extensibility.
The same event will always be handled by any module you depend on, before it is handed to you.
Note also that any component can handle an event, event listeners do not need to be exposed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implicit_and_explicit_ordering"><a class="anchor" href="#_implicit_and_explicit_ordering"></a>Implicit and explicit ordering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve illustrated the impact of ordering on components and event handling.</p>
</div>
<div class="paragraph">
<p>In a regular Spring application most components are considered not-ordered unless they are explicitly ordered.
Beans will be returned in order if they implement <code>Ordered</code> or have the <code>@Order</code> annotation.
If they have neither of these, the order in which they will be returned cannot reliably be determined.
The same goes for <code>@EventListener</code> methods, unless explicitly ordered using <code>@Order</code>, the handling order is non-deterministic.</p>
</div>
<div class="paragraph">
<p>In an Across based modular application, the order of a lot of things is implicit.
Because module A depends on module B, it will be ordered after it, which means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>components from B will be created before the ones from A (B will bootstrap before A)</p>
</li>
<li>
<p><em>unless otherwise specified</em>: components from B will be ordered before the ones from A in retrieval/auto-wiring scenarios</p>
</li>
<li>
<p><em>unless otherwise specified</em>: events will be handled by event listeners from B before the ones from A, no matter who publishes the event</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course sometimes it is required to break out of the default behaviour, which is still possible (<em>unless otherwise specified</em>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>using <code>@OrderInModule</code> and equivalents you can order components inside a single module</p>
</li>
<li>
<p>using <code>@Order</code> you can influence the global ordering in your application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To illustrate this, let&#8217;s revisit the failing test from above, and update the <code>SupplierService</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/modules/three/SupplierService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
@RequiredArgsConstructor
public class SupplierService
{
    ...

	@EventListener
	@Order(Ordered.HIGHEST_PRECEDENCE)
	public void receive( SomeEvent event ) {
		event.add( getClass().getSimpleName() );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Re-run and you will see the test is green again.
The <code>@Order(HIGHEST_PRECEDENCE)</code> breaks out of the default ordering and pushes that event listener to the very top of the handling queue.</p>
</div>
<div class="paragraph">
<p>Going into the details of how the ordering works behind the scene would lead us too far, but suffice to say that reliable default ordering is a cornerstone of building modular monoliths with Spring Boot and Across.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_revisiting_the_across_application"><a class="anchor" href="#_revisiting_the_across_application"></a>Revisiting the Across application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Early on in this post I promised to get back to the <code>DemoApplicationModule</code> and <code>AcrossContextPostProcessorModule</code> that you get when running the <code>DemoApplication</code>.</p>
</div>
<div class="listingblock">
<div class="title">Console excerpt from starting the blank application</div>
<div class="content">
<pre class="highlightjs highlight"><code>: ---
: AcrossContext: DemoApplication (AcrossContext-1)
: Bootstrapping 2 modules in the following order:
: 1 - DemoApplicationModule [resources: demo]: class com.foreach.across.core.DynamicAcrossModule$DynamicApplicationModule
: 2 - AcrossContextPostProcessorModule [resources: AcrossContextPostProcessorModule]: class com.foreach.across.core.AcrossContextConfigurationModule
: ---</code></pre>
</div>
</div>
<div class="paragraph">
<p>I have already explained that the <code>AcrossContextPostProcessorModule</code> gets added to every Across based application.
It is a technical module and going into the details of this one would lead us too far for this first post.</p>
</div>
<div class="paragraph">
<p>The <code>DemoApplicationModule</code> however gets added because we use <code>@AcrossApplication</code>, and it is the equivalent of the base package in a regular <code>@SpringBootApplication</code>.
Across encourages you to bundle all your application code inside modules that interact with each other.
A top-level component scan is not allowed, but a default dynamic module is automatically added which uses the <code>application</code> child package as the module contents.</p>
</div>
<div class="paragraph">
<p>An <code>AcrossModule</code> descriptor is not required for this module, it is entirely package based.
Many Across applications use several shared modules and have a limited set of application-specific code using those module features.
The dynamic application module is the default spot to put all that application specific code.
It does not allow (or requires) you to define explicit dependencies but it always bootstraps after all other modules in the application.</p>
</div>
<div class="sect2">
<h3 id="_using_the_application_module"><a class="anchor" href="#_using_the_application_module"></a>Using the application module</h3>
<div class="paragraph">
<p>Let&#8217;s finish this tutorial with a small example of using the application module.
Update the <code>DemoApplication</code> to add our newly created modules:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/DemoApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AcrossApplication(
        modules = {

        }
)
public class DemoApplication
{
    @Bean
    public ModuleOne moduleOne() {
        return new ModuleOne();
    }

    @Bean
    public ModuleTwo moduleTwo() {
        return new ModuleTwo();
    }

    @Bean
    public ModuleThree moduleThree() {
        return new ModuleThree();
    }

    public static void main(String[] args) {
        SpringApplication springApplication = new SpringApplication(DemoApplication.class);
        springApplication.setDefaultProperties(Collections.singletonMap("spring.config.location", "${user.home}/dev-configs/demo-application.yml"));
        springApplication.run(args);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And add an application event listener to the <code>application</code> package:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/example/demo/application/ApplicationComponent.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Slf4j
public class ApplicationComponent
{
    public ApplicationComponent() {
        LOG.info("Component created: {}", getClass());
    }

    @EventListener
    public void receive(SomeEvent event) {
        event.add(getClass().getSimpleName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your project structure should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.example.demo/
  application/
    ApplicationComponent
  modules/
    SomeEvent
    one/
      ModuleOne
      InternalComponentOne
      ExposedComponentOne
    two/
      ModuleTwo
      InternalComponentTwo
      ExposedComponentTwo
    three/
      ModuleThree.java
      SupplierService.java
  DemoApplication</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our application module now also handles <code>SomeEvent</code>, let&#8217;s update the application integration test <code>ITDemoApplication</code> to test for that:</p>
</div>
<div class="listingblock">
<div class="title">src/test/java/it/ITDemoApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ITDemoApplication
{
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private SupplierService supplierService;

    @Test
    public void bootstrappedOk() throws Exception {
        // Test should really do something - but when it gets called, bootstrap has been successful
        assertNotNull(mockMvc);
    }

    @Test
    public void eventShouldBeHandledByAllModules() {
        assertEquals(
                Arrays.asList("SupplierService", "InternalComponentOne", "InternalComponentTwo", "ApplicationComponent"),
                supplierService.getEventListeners()
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As <code>SupplierService</code> is an exposed component, we can auto-wire it directly in our Spring integration test class.</p>
</div>
<div class="paragraph">
<p>Running the <code>eventShouldBeHandledByAllModules()</code> test should succeed.
The test result illustrates that the <code>ApplicationComponent</code> gets created and the <code>@EventListener</code> method called.
If you look at the console output, you can clearly see that the <code>ApplicationComponent</code> is part of the automatically defined <code>DemoApplicationModule</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wrapping_it_up"><a class="anchor" href="#_wrapping_it_up"></a>Wrapping it up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>And so we come to the end of this introduction about building modular applications with Spring Boot and Across.
We&#8217;ve focused on some basic concepts where the modular approach differs from a regular Spring Boot application.</p>
</div>
<div class="paragraph">
<p>Features like module dependencies, reliable ordering and event handling are the very basic building blocks you&#8217;ll need.</p>
</div>
<div class="paragraph">
<p>We barely scratched the surface and there&#8217;s plenty more to come.
In a next post we&#8217;ll tackle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name based resolving and transitive loading of modules</p>
</li>
<li>
<p>working with conditionals for modules and components inside modules</p>
</li>
<li>
<p>how modules can manage their own installation and run data or schema migrations</p>
</li>
<li>
<p>embedding resources like message codes or templates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the meantime you can find more information on all things Across on <a href="https://across.foreach.be">across.foreach.be</a>.</p>
</div>
<div class="paragraph">
<p>The full source code of this tutorial is available on: <a href="https://github.com/ForeachOS/blog-modular-monoliths-across" class="bare">https://github.com/ForeachOS/blog-modular-monoliths-across</a></p>
</div>
</div>
</div>
</article>
<aside class="article-aside hidden" role="navigation">
  <h3 class="toc-title">Contents</h3>
  <div id="article-toc"></div>
</aside>
  </main>
</div>
<footer class="footer">
  <p>The Across documentation site is generated using <a href="https://antora.org" target="_blank">Antora</a>.</p>
  <div class="footer-totop">
    <!--srcset="/acrossWebsite/img/foreach-logo@2x.png 2x"-->
    <a class="footer-partner" href="http://foreach.be/" target="_blank">
      sponsored by <svg width="20" height="20" viewBox="0 0 277 311" xmlns="http://www.w3.org/2000/svg">
        <g fill="none" fill-rule="evenodd">
          <path d="M27 307.3V133.5H.9V92.7H27v-8.8c0-24.1 4.3-46.5 19.7-64.1C58.2 6.6 74.7.1 92.9.1c13.4 0 23.7 2.2 31.2 4.8l-5.9 44.8c-3.9-1.8-9.5-2.6-15.8-2.6-17.4 0-23.7 16.7-23.7 35.5v10.1h33.6v40.8H78.7v173.8H27z" fill="#FFCE01" fill-rule="nonzero"></path>
          <path d="M229.2 181c0-27.6-6.3-49.1-21.7-49.1-17 0-23.7 27.7-24.1 49.1h45.8zM183 221.4c.8 33.4 18.2 45.6 41.1 45.6 14.6 0 27.6-3.5 36.7-7l7.1 41.2c-13.4 5.7-33.6 9.7-53.3 9.7-52.5 0-81.4-38.6-81.4-105.8 0-72 33.6-115 77.4-115 41.5 0 65.6 36.4 65.6 101.4 0 15.4-.4 23.7-1.6 29.8H183v.1z" fill="#FFF" fill-rule="nonzero"></path>
        </g>
      </svg>
    </a>
    <a href="#section-top">
      <svg width="34" height="34" viewBox="0 0 62 62" xmlns="http://www.w3.org/2000/svg">
        <title>icon</title>
        <g transform="rotate(-90 30.5 30.5)" fill="none" fill-rule="evenodd">
          <circle stroke="#ffffff" fill="#1D2A3A" transform="rotate(180 30.007 30.942)" cx="30.007" cy="30.942" r="30"></circle>
          <path fill="#ffffff" d="M25 38.884h3.713l6.3-7.797-6.3-8.087-3.713.064 6.155 7.972"></path>
        </g>
      </svg>
    </a>
  </div>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.1.1/tocbot.min.js"></script>
<script src="../../../_/js/site.js"></script>
<script src="../../../_/js/vendor/highlight.js"></script>
<script>hljs.initHighlighting()</script>
<script>
  tocbot.init( {
                 tocSelector: '#article-toc',
                 contentSelector: 'article',
                 headingSelector: 'h2, h3, h4',
                 collapseDepth: 3,
                 positionFixedSelector: '#article-toc',
                 scrollSmooth: false
               } );
  var tocList = document.getElementById( 'article-toc' ).getElementsByClassName( 'toc-list' );
  if ( tocList && tocList.length > 0 && tocList[0].childNodes.length > 0 ) {
    document.getElementById( 'article-toc' ).parentNode.classList.remove( 'hidden' );
  }
</script>
  </body>
</html>
